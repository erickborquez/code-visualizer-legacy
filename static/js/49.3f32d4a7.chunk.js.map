{"version":3,"sources":["../node_modules/brace/mode/golang.js"],"names":["ace","define","acequire","exports","module","oop","TextHighlightRules","DocCommentHighlightRules","this","$rules","token","regex","getTagRule","defaultToken","caseInsensitive","inherits","start","getStartRule","next","getEndRule","GolangHighlightRules","keywordMapper","createKeywordMapper","stringEscapeRe","replace","val","length","type","slice","value","embedRules","Range","MatchingBraceOutdent","checkOutdent","line","input","test","autoOutdent","doc","row","match","getLine","column","openBracePos","findMatchingBracket","indent","$getIndent","call","prototype","BaseFoldMode","FoldMode","commentRegex","foldingStartMarker","RegExp","source","foldingStopMarker","end","singleLineBlockCommentRe","tripleStarBlockCommentRe","startRegionRe","_getFoldWidgetBase","getFoldWidget","session","foldStyle","fw","getFoldWidgetRange","forceMultiline","getCommentRegionBlock","i","index","openingBracketBlock","range","getCommentFoldRange","isMultiLine","getSectionRange","closingBracketBlock","startIndent","search","startRow","startColumn","endRow","maxRow","getLength","subRange","re","depth","m","exec","TextMode","Mode","CstyleBehaviour","CStyleFoldMode","HighlightRules","$outdent","foldingRules","$behaviour","lineCommentStart","blockComment","getNextLineIndent","state","tab","tokenizedLine","getTokenizer","getLineTokens","tokens","$id"],"mappings":"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","file":"static/js/49.3f32d4a7.chunk.js","sourcesContent":["ace.define(\"ace/mode/doc_comment_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../lib/oop\");\nvar TextHighlightRules = acequire(\"./text_highlight_rules\").TextHighlightRules;\n\nvar DocCommentHighlightRules = function() {\n    this.$rules = {\n        \"start\" : [ {\n            token : \"comment.doc.tag\",\n            regex : \"@[\\\\w\\\\d_]+\" // TODO: fix email addresses\n        }, \n        DocCommentHighlightRules.getTagRule(),\n        {\n            defaultToken : \"comment.doc\",\n            caseInsensitive: true\n        }]\n    };\n};\n\noop.inherits(DocCommentHighlightRules, TextHighlightRules);\n\nDocCommentHighlightRules.getTagRule = function(start) {\n    return {\n        token : \"comment.doc.tag.storage.type\",\n        regex : \"\\\\b(?:TODO|FIXME|XXX|HACK)\\\\b\"\n    };\n};\n\nDocCommentHighlightRules.getStartRule = function(start) {\n    return {\n        token : \"comment.doc\", // doc comment\n        regex : \"\\\\/\\\\*(?=\\\\*)\",\n        next  : start\n    };\n};\n\nDocCommentHighlightRules.getEndRule = function (start) {\n    return {\n        token : \"comment.doc\", // closing comment\n        regex : \"\\\\*\\\\/\",\n        next  : start\n    };\n};\n\n\nexports.DocCommentHighlightRules = DocCommentHighlightRules;\n\n});\n\nace.define(\"ace/mode/golang_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/doc_comment_highlight_rules\",\"ace/mode/text_highlight_rules\"], function(acequire, exports, module) {\n    var oop = acequire(\"../lib/oop\");\n    var DocCommentHighlightRules = acequire(\"./doc_comment_highlight_rules\").DocCommentHighlightRules;\n    var TextHighlightRules = acequire(\"./text_highlight_rules\").TextHighlightRules;\n\n    var GolangHighlightRules = function() {\n        var keywords = (\n            \"else|break|case|return|goto|if|const|select|\" +\n            \"continue|struct|default|switch|for|range|\" +\n            \"func|import|package|chan|defer|fallthrough|go|interface|map|range|\" +\n            \"select|type|var\"\n        );\n        var builtinTypes = (\n            \"string|uint8|uint16|uint32|uint64|int8|int16|int32|int64|float32|\" +\n            \"float64|complex64|complex128|byte|rune|uint|int|uintptr|bool|error\"\n        );\n        var builtinFunctions = (\n            \"new|close|cap|copy|panic|panicln|print|println|len|make|delete|real|recover|imag|append\"\n        );\n        var builtinConstants = (\"nil|true|false|iota\");\n\n        var keywordMapper = this.createKeywordMapper({\n            \"keyword\": keywords,\n            \"constant.language\": builtinConstants,\n            \"support.function\": builtinFunctions,\n            \"support.type\": builtinTypes\n        }, \"\");\n        \n        var stringEscapeRe = \"\\\\\\\\(?:[0-7]{3}|x\\\\h{2}|u{4}|U\\\\h{6}|[abfnrtv'\\\"\\\\\\\\])\".replace(/\\\\h/g, \"[a-fA-F\\\\d]\");\n\n        this.$rules = {\n            \"start\" : [\n                {\n                    token : \"comment\",\n                    regex : \"\\\\/\\\\/.*$\"\n                },\n                DocCommentHighlightRules.getStartRule(\"doc-start\"),\n                {\n                    token : \"comment.start\", // multi line comment\n                    regex : \"\\\\/\\\\*\",\n                    next : \"comment\"\n                }, {\n                    token : \"string\", // single line\n                    regex : /\"(?:[^\"\\\\]|\\\\.)*?\"/\n                }, {\n                    token : \"string\", // raw\n                    regex : '`',\n                    next : \"bqstring\"\n                }, {\n                    token : \"constant.numeric\", // rune\n                    regex : \"'(?:[^\\\\'\\uD800-\\uDBFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|\" + stringEscapeRe.replace('\"', '')  + \")'\"\n                }, {\n                    token : \"constant.numeric\", // hex\n                    regex : \"0[xX][0-9a-fA-F]+\\\\b\" \n                }, {\n                    token : \"constant.numeric\", // float\n                    regex : \"[+-]?\\\\d+(?:(?:\\\\.\\\\d*)?(?:[eE][+-]?\\\\d+)?)?\\\\b\"\n                }, {\n                    token : [\"keyword\", \"text\", \"entity.name.function\"],\n                    regex : \"(func)(\\\\s+)([a-zA-Z_$][a-zA-Z0-9_$]*)\\\\b\"\n                }, {\n                    token : function(val) {\n                        if (val[val.length - 1] == \"(\") {\n                            return [{\n                                type: keywordMapper(val.slice(0, -1)) || \"support.function\",\n                                value: val.slice(0, -1)\n                            }, {\n                                type: \"paren.lparen\",\n                                value: val.slice(-1)\n                            }];\n                        }\n                        \n                        return keywordMapper(val) || \"identifier\";\n                    },\n                    regex : \"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\\\\(?\"\n                }, {\n                    token : \"keyword.operator\",\n                    regex : \"!|\\\\$|%|&|\\\\*|\\\\-\\\\-|\\\\-|\\\\+\\\\+|\\\\+|~|==|=|!=|<=|>=|<<=|>>=|>>>=|<>|<|>|!|&&|\\\\|\\\\||\\\\?\\\\:|\\\\*=|%=|\\\\+=|\\\\-=|&=|\\\\^=\"\n                }, {\n                    token : \"punctuation.operator\",\n                    regex : \"\\\\?|\\\\:|\\\\,|\\\\;|\\\\.\"\n                }, {\n                    token : \"paren.lparen\",\n                    regex : \"[[({]\"\n                }, {\n                    token : \"paren.rparen\",\n                    regex : \"[\\\\])}]\"\n                }, {\n                    token : \"text\",\n                    regex : \"\\\\s+\"\n                }\n            ],\n            \"comment\" : [\n                {\n                    token : \"comment.end\",\n                    regex : \"\\\\*\\\\/\",\n                    next : \"start\"\n                }, {\n                    defaultToken : \"comment\"\n                }\n            ],\n            \"bqstring\" : [\n                {\n                    token : \"string\",\n                    regex : '`',\n                    next : \"start\"\n                }, {\n                    defaultToken : \"string\"\n                }\n            ]\n        };\n\n        this.embedRules(DocCommentHighlightRules, \"doc-\",\n            [ DocCommentHighlightRules.getEndRule(\"start\") ]);\n    };\n    oop.inherits(GolangHighlightRules, TextHighlightRules);\n\n    exports.GolangHighlightRules = GolangHighlightRules;\n});\n\nace.define(\"ace/mode/matching_brace_outdent\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar Range = acequire(\"../range\").Range;\n\nvar MatchingBraceOutdent = function() {};\n\n(function() {\n\n    this.checkOutdent = function(line, input) {\n        if (! /^\\s+$/.test(line))\n            return false;\n\n        return /^\\s*\\}/.test(input);\n    };\n\n    this.autoOutdent = function(doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\})/);\n\n        if (!match) return 0;\n\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({row: row, column: column});\n\n        if (!openBracePos || openBracePos.row == row) return 0;\n\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column-1), indent);\n    };\n\n    this.$getIndent = function(line) {\n        return line.match(/^\\s*/)[0];\n    };\n\n}).call(MatchingBraceOutdent.prototype);\n\nexports.MatchingBraceOutdent = MatchingBraceOutdent;\n});\n\nace.define(\"ace/mode/folding/cstyle\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/range\",\"ace/mode/folding/fold_mode\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../../lib/oop\");\nvar Range = acequire(\"../../range\").Range;\nvar BaseFoldMode = acequire(\"./fold_mode\").FoldMode;\n\nvar FoldMode = exports.FoldMode = function(commentRegex) {\n    if (commentRegex) {\n        this.foldingStartMarker = new RegExp(\n            this.foldingStartMarker.source.replace(/\\|[^|]*?$/, \"|\" + commentRegex.start)\n        );\n        this.foldingStopMarker = new RegExp(\n            this.foldingStopMarker.source.replace(/\\|[^|]*?$/, \"|\" + commentRegex.end)\n        );\n    }\n};\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n    \n    this.foldingStartMarker = /([\\{\\[\\(])[^\\}\\]\\)]*$|^\\s*(\\/\\*)/;\n    this.foldingStopMarker = /^[^\\[\\{\\(]*([\\}\\]\\)])|^[\\s\\*]*(\\*\\/)/;\n    this.singleLineBlockCommentRe= /^\\s*(\\/\\*).*\\*\\/\\s*$/;\n    this.tripleStarBlockCommentRe = /^\\s*(\\/\\*\\*\\*).*\\*\\/\\s*$/;\n    this.startRegionRe = /^\\s*(\\/\\*|\\/\\/)#?region\\b/;\n    this._getFoldWidgetBase = this.getFoldWidget;\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n    \n        if (this.singleLineBlockCommentRe.test(line)) {\n            if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))\n                return \"\";\n        }\n    \n        var fw = this._getFoldWidgetBase(session, foldStyle, row);\n    \n        if (!fw && this.startRegionRe.test(line))\n            return \"start\"; // lineCommentRegionStart\n    \n        return fw;\n    };\n\n    this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {\n        var line = session.getLine(row);\n        \n        if (this.startRegionRe.test(line))\n            return this.getCommentRegionBlock(session, line, row);\n        \n        var match = line.match(this.foldingStartMarker);\n        if (match) {\n            var i = match.index;\n\n            if (match[1])\n                return this.openingBracketBlock(session, match[1], row, i);\n                \n            var range = session.getCommentFoldRange(row, i + match[0].length, 1);\n            \n            if (range && !range.isMultiLine()) {\n                if (forceMultiline) {\n                    range = this.getSectionRange(session, row);\n                } else if (foldStyle != \"all\")\n                    range = null;\n            }\n            \n            return range;\n        }\n\n        if (foldStyle === \"markbegin\")\n            return;\n\n        var match = line.match(this.foldingStopMarker);\n        if (match) {\n            var i = match.index + match[0].length;\n\n            if (match[1])\n                return this.closingBracketBlock(session, match[1], row, i);\n\n            return session.getCommentFoldRange(row, i, -1);\n        }\n    };\n    \n    this.getSectionRange = function(session, row) {\n        var line = session.getLine(row);\n        var startIndent = line.search(/\\S/);\n        var startRow = row;\n        var startColumn = line.length;\n        row = row + 1;\n        var endRow = row;\n        var maxRow = session.getLength();\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var indent = line.search(/\\S/);\n            if (indent === -1)\n                continue;\n            if  (startIndent > indent)\n                break;\n            var subRange = this.getFoldWidgetRange(session, \"all\", row);\n            \n            if (subRange) {\n                if (subRange.start.row <= startRow) {\n                    break;\n                } else if (subRange.isMultiLine()) {\n                    row = subRange.end.row;\n                } else if (startIndent == indent) {\n                    break;\n                }\n            }\n            endRow = row;\n        }\n        \n        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);\n    };\n    this.getCommentRegionBlock = function(session, line, row) {\n        var startColumn = line.search(/\\s*$/);\n        var maxRow = session.getLength();\n        var startRow = row;\n        \n        var re = /^\\s*(?:\\/\\*|\\/\\/|--)#?(end)?region\\b/;\n        var depth = 1;\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var m = re.exec(line);\n            if (!m) continue;\n            if (m[1]) depth--;\n            else depth++;\n\n            if (!depth) break;\n        }\n\n        var endRow = row;\n        if (endRow > startRow) {\n            return new Range(startRow, startColumn, endRow, line.length);\n        }\n    };\n\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/golang\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/golang_highlight_rules\",\"ace/mode/matching_brace_outdent\",\"ace/mode/behaviour/cstyle\",\"ace/mode/folding/cstyle\"], function(acequire, exports, module) {\n\nvar oop = acequire(\"../lib/oop\");\nvar TextMode = acequire(\"./text\").Mode;\nvar GolangHighlightRules = acequire(\"./golang_highlight_rules\").GolangHighlightRules;\nvar MatchingBraceOutdent = acequire(\"./matching_brace_outdent\").MatchingBraceOutdent;\nvar CstyleBehaviour = acequire(\"./behaviour/cstyle\").CstyleBehaviour;\nvar CStyleFoldMode = acequire(\"./folding/cstyle\").FoldMode;\n\nvar Mode = function() {\n    this.HighlightRules = GolangHighlightRules;\n    this.$outdent = new MatchingBraceOutdent();\n    this.foldingRules = new CStyleFoldMode();\n    this.$behaviour = new CstyleBehaviour();\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n    \n    this.lineCommentStart = \"//\";\n    this.blockComment = {start: \"/*\", end: \"*/\"};\n\n    this.getNextLineIndent = function(state, line, tab) {\n        var indent = this.$getIndent(line);\n\n        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n        var tokens = tokenizedLine.tokens;\n        var endState = tokenizedLine.state;\n\n        if (tokens.length && tokens[tokens.length-1].type == \"comment\") {\n            return indent;\n        }\n        \n        if (state == \"start\") {\n            var match = line.match(/^.*[\\{\\(\\[]\\s*$/);\n            if (match) {\n                indent += tab;\n            }\n        }\n\n        return indent;\n    };//end getNextLineIndent\n\n    this.checkOutdent = function(state, line, input) {\n        return this.$outdent.checkOutdent(line, input);\n    };\n\n    this.autoOutdent = function(state, doc, row) {\n        this.$outdent.autoOutdent(doc, row);\n    };\n\n    this.$id = \"ace/mode/golang\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n});\n"],"sourceRoot":""}